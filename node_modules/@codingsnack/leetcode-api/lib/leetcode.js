"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tag_info_1 = require("./tag-info");
const my_lists_1 = require("./my-lists");
const graphql_helper_1 = require("./graphql-helper");
const problem_1 = require("./problem");
const problem_list_1 = require("./problem-list");
const submission_list_1 = require("./submission-list");
const http_helper_1 = require("./http-helper");
class Leetcode {
    constructor(config) {
        const { csrfToken, session } = config;
        this.graphQLHelper = new graphql_helper_1.GraphQLHelper(csrfToken, session);
        this.httpHelper = new http_helper_1.HttpHelper();
    }
    getProblem(titleSlug) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getProblem(titleSlug);
            const { question } = data;
            return new problem_1.Problem(question);
        });
    }
    getMyLists() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getMyLists();
            const { favoritesLists } = data;
            const { allFavorites, watchedFavorites } = favoritesLists;
            return new my_lists_1.MyLists(allFavorites, watchedFavorites);
        });
    }
    getProblems(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getProblems(params);
            const { problemsetQuestionList } = data;
            const { total, questions } = problemsetQuestionList;
            return new problem_list_1.ProblemList(total, questions);
        });
    }
    getSubmissions(titleSlug) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getSubmissions(titleSlug);
            const { submissionList } = data;
            const { lastKey, hasNext, submissions } = submissionList;
            return new submission_list_1.SubmissionList(lastKey, hasNext, submissions);
        });
    }
    getRandomQuestion() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getRandomQuestion();
            const { randomQuestion } = data;
            const { titleSlug } = randomQuestion;
            return yield this.getProblem(titleSlug);
        });
    }
    getPublicList(listId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.httpHelper.getPublicList(listId);
        });
    }
    getProblemsByTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getProblemsByTag(tag);
            const { topicTag } = data;
            const { name, slug, questions, frequencies } = topicTag;
            return new tag_info_1.TagInfo(name, slug, questions, frequencies);
        });
    }
    getProblemsByCompany(company) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.graphQLHelper.getProblemsByCompany(company);
            const { companyTag } = data;
            const { name, slug, questions, frequencies } = companyTag;
            return new tag_info_1.TagInfo(name, slug, questions, frequencies);
        });
    }
    getSimilarProblems(titleSlug, depth = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const problem = yield this.getProblem(titleSlug);
            const visited = new Set();
            const q = [];
            q.push(problem);
            while (q.length > 0 && depth > 0) {
                const length = q.length;
                for (let i = 0; i < length; i++) {
                    const currentProblem = q.shift();
                    if (visited.has(currentProblem.titleSlug))
                        continue;
                    visited.add(currentProblem.titleSlug);
                    yield this.fillSimilarProblems(currentProblem);
                    q.push(...currentProblem.similarProblems);
                }
                depth--;
            }
            return problem;
        });
    }
    fillSimilarProblems(problem) {
        return __awaiter(this, void 0, void 0, function* () {
            const similarProblemsParsed = this.parseSimilarQuestions(problem);
            for (let i = 0; i < similarProblemsParsed.length; i++) {
                const item = similarProblemsParsed[i];
                const { titleSlug } = item;
                const currentProblem = yield this.getProblem(titleSlug);
                problem.similarProblems.push(currentProblem);
            }
        });
    }
    parseSimilarQuestions(problem) {
        const { similarQuestions } = problem;
        return similarQuestions ? JSON.parse(problem.similarQuestions) : [];
    }
}
exports.default = Leetcode;
